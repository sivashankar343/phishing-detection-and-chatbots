// Character sets for password generation
const UPPERCASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
const LOWERCASE = 'abcdefghijklmnopqrstuvwxyz';
const NUMBERS = '0123456789';
const SYMBOLS = '!@#$%^&*()_+-=[]{}|;:,.<>?~';

// DOM Elements
const lengthSlider = document.getElementById('passwordLength');
const lengthValue = document.getElementById('lengthValue');
const generateBtn = document.getElementById('generateBtn');
const passwordDisplay = document.getElementById('passwordDisplay');
const generatedPassword = document.getElementById('generatedPassword');
const copyBtn = document.getElementById('copyBtn');
const downloadBtn = document.getElementById('downloadBtn');
const regenerateBtn = document.getElementById('regenerateBtn');
const strengthBadge = document.getElementById('strengthBadge');
const strengthMeter = document.getElementById('strengthMeter');
const strengthText = document.getElementById('strengthText');

// User data inputs
const userNameInput = document.getElementById('userName');
const platformSelect = document.getElementById('platformSelect');
const userBirthdayInput = document.getElementById('userBirthday');
const userPhoneInput = document.getElementById('userPhone');

// Checkboxes
const includeUppercase = document.getElementById('includeUppercase');
const includeLowercase = document.getElementById('includeLowercase');
const includeNumbers = document.getElementById('includeNumbers');
const includeSymbols = document.getElementById('includeSymbols');

// Update length value display
lengthSlider.addEventListener('input', (e) => {
    lengthValue.textContent = e.target.value;
});

// Generate password with AI-powered randomness
function generateSecurePassword(length, options) {
    let charset = '';
    let password = '';

    // Build character set based on options
    if (options.uppercase) charset += UPPERCASE;
    if (options.lowercase) charset += LOWERCASE;
    if (options.numbers) charset += NUMBERS;
    if (options.symbols) charset += SYMBOLS;

    if (charset === '') {
        alert('Please select at least one character type!');
        return null;
    }

    // Use crypto.getRandomValues for cryptographically strong random numbers
    const randomValues = new Uint32Array(length);
    window.crypto.getRandomValues(randomValues);

    // Ensure at least one character from each selected type
    const guaranteedChars = [];
    if (options.uppercase) guaranteedChars.push(UPPERCASE[Math.floor(Math.random() * UPPERCASE.length)]);
    if (options.lowercase) guaranteedChars.push(LOWERCASE[Math.floor(Math.random() * LOWERCASE.length)]);
    if (options.numbers) guaranteedChars.push(NUMBERS[Math.floor(Math.random() * NUMBERS.length)]);
    if (options.symbols) guaranteedChars.push(SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)]);

    // Generate remaining characters
    for (let i = 0; i < length - guaranteedChars.length; i++) {
        const randomIndex = randomValues[i] % charset.length;
        password += charset[randomIndex];
    }

    // Insert guaranteed characters at random positions
    guaranteedChars.forEach(char => {
        const randomPosition = Math.floor(Math.random() * password.length);
        password = password.slice(0, randomPosition) + char + password.slice(randomPosition);
    });

    // Trim to exact length if needed
    password = password.slice(0, length);

    // Shuffle the password one more time for extra randomness
    password = shuffleString(password);

    return password;
}

// Shuffle string using Fisher-Yates algorithm
function shuffleString(str) {
    const arr = str.split('');
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr.join('');
}

// Validate that password is not related to user data
function validatePasswordSecurity(password, userData) {
    const warnings = [];

    // Convert password to lowercase for comparison
    const passLower = password.toLowerCase();

    // Check against name
    if (userData.name) {
        const nameParts = userData.name.toLowerCase().split(' ');
        nameParts.forEach(part => {
            if (part.length > 2 && passLower.includes(part)) {
                warnings.push(`Password contains part of your name: "${part}"`);
            }
        });
    }

    // Check against birthday
    if (userData.birthday) {
        const birthParts = userData.birthday.split('-'); // YYYY-MM-DD
        birthParts.forEach(part => {
            if (password.includes(part)) {
                warnings.push('Password contains your birth date');
            }
        });
    }

    // Check against phone
    if (userData.phone) {
        const phoneDigits = userData.phone.replace(/\D/g, '');
        if (phoneDigits.length > 3) {
            const phoneSegments = [
                phoneDigits.slice(0, 3),
                phoneDigits.slice(-4),
                phoneDigits.slice(3, 6)
            ];
            phoneSegments.forEach(segment => {
                if (password.includes(segment)) {
                    warnings.push('Password contains part of your phone number');
                }
            });
        }
    }

    return warnings;
}

// Calculate password strength
function calculateStrength(password) {
    let score = 0;

    // Length score
    if (password.length >= 8) score += 1;
    if (password.length >= 12) score += 1;
    if (password.length >= 16) score += 1;
    if (password.length >= 20) score += 1;

    // Character variety
    if (/[a-z]/.test(password)) score += 1;
    if (/[A-Z]/.test(password)) score += 1;
    if (/[0-9]/.test(password)) score += 1;
    if (/[^A-Za-z0-9]/.test(password)) score += 2;

    // No repeated characters
    if (!/(.)\1{2,}/.test(password)) score += 1;

    // Map score to strength level
    if (score <= 3) return { level: 'weak', text: 'Weak', color: 'weak' };
    if (score <= 6) return { level: 'medium', text: 'Medium', color: 'medium' };
    if (score <= 9) return { level: 'strong', text: 'Strong', color: 'strong' };
    return { level: 'very-strong', text: 'Very Strong', color: 'very-strong' };
}

// Update strength display
function updateStrengthDisplay(strength) {
    // Update badge
    strengthBadge.className = `strength-badge strength-${strength.color}`;
    strengthBadge.textContent = strength.text;

    // Update meter
    strengthMeter.className = `strength-fill ${strength.level}`;

    // Update text
    strengthText.className = `text-sm font-bold`;
    strengthText.textContent = strength.text;

    // Color text based on strength
    if (strength.level === 'weak') strengthText.style.color = '#ef4444';
    else if (strength.level === 'medium') strengthText.style.color = '#fb923c';
    else if (strength.level === 'strong') strengthText.style.color = '#22c55e';
    else strengthText.style.color = '#06b6d4';
}

// Get user data
function getUserData() {
    return {
        name: userNameInput.value.trim(),
        platform: platformSelect.value,
        birthday: userBirthdayInput.value,
        phone: userPhoneInput.value.trim()
    };
}

// Main generate function
function handleGenerate() {
    const length = parseInt(lengthSlider.value);
    const options = {
        uppercase: includeUppercase.checked,
        lowercase: includeLowercase.checked,
        numbers: includeNumbers.checked,
        symbols: includeSymbols.checked
    };

    // Generate password
    let password = generateSecurePassword(length, options);

    if (!password) return;

    // Get user data
    const userData = getUserData();

    // Validate security - regenerate if password relates to user data
    let attempts = 0;
    const maxAttempts = 10;
    let warnings = validatePasswordSecurity(password, userData);

    while (warnings.length > 0 && attempts < maxAttempts) {
        password = generateSecurePassword(length, options);
        warnings = validatePasswordSecurity(password, userData);
        attempts++;
    }

    if (warnings.length > 0) {
        console.warn('Generated password after max attempts:', warnings);
    }

    // Display password
    generatedPassword.textContent = password;
    passwordDisplay.classList.remove('hidden');
    passwordDisplay.classList.add('fade-in');

    // Calculate and display strength
    const strength = calculateStrength(password);
    updateStrengthDisplay(strength);

    // Store password for later use
    window.currentPassword = password;
}

// Copy to clipboard
async function copyToClipboard() {
    const password = generatedPassword.textContent;

    try {
        await navigator.clipboard.writeText(password);

        // Visual feedback
        const originalHTML = copyBtn.innerHTML;
        copyBtn.innerHTML = `
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
        `;
        copyBtn.style.color = '#22c55e';

        setTimeout(() => {
            copyBtn.innerHTML = originalHTML;
            copyBtn.style.color = '';
        }, 2000);
    } catch (err) {
        alert('Failed to copy password. Please copy manually.');
        console.error('Copy failed:', err);
    }
}

// Store the file handle globally
let fileHandle = null;

// Download/Save ALL passwords to ONE file - DIRECT SAVE TO USER'S LOCATION
async function downloadPassword() {
    const password = generatedPassword.textContent;
    const userData = getUserData();
    const now = new Date();
    const timestamp = now.toLocaleString('en-US', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: true
    });

    // Platform names mapping
    const platformNames = {
        instagram: 'Instagram',
        whatsapp: 'WhatsApp',
        email: 'Email',
        facebook: 'Facebook',
        twitter: 'X (Twitter)',
        linkedin: 'LinkedIn',
        tiktok: 'TikTok',
        snapchat: 'Snapchat',
        discord: 'Discord',
        telegram: 'Telegram',
        reddit: 'Reddit',
        netflix: 'Netflix',
        spotify: 'Spotify',
        amazon: 'Amazon',
        paypal: 'PayPal',
        banking: 'Banking',
        gaming: 'Gaming',
        work: 'Work Account',
        other: 'Other'
    };

    // Get existing password history from localStorage
    let passwordHistory = localStorage.getItem('passwordHistory') || '';

    // If this is the first entry, add simple header
    if (!passwordHistory) {
        passwordHistory = `GENERATED PASSWORDS\n`;
        passwordHistory += `===================\n\n`;
    }

    // Add new password entry in SIMPLE CLEAN format
    passwordHistory += `[${timestamp}]\n`;

    if (userData.platform) {
        const platformName = platformNames[userData.platform] || userData.platform;
        passwordHistory += `Platform: ${platformName}\n`;
    } else {
        passwordHistory += `Platform: Not specified\n`;
    }

    if (userData.name) {
        passwordHistory += `User: ${userData.name}\n`;
    }

    passwordHistory += `Password: ${password}\n\n`;

    // Save updated history to localStorage
    localStorage.setItem('passwordHistory', passwordHistory);

    // Try to use File System Access API for direct file save
    try {
        // Check if the API is supported
        if ('showSaveFilePicker' in window) {
            // If we don't have a file handle yet, ask user to pick/create a file
            if (!fileHandle) {
                fileHandle = await window.showSaveFilePicker({
                    suggestedName: 'password-history.txt',
                    types: [{
                        description: 'Text Files',
                        accept: { 'text/plain': ['.txt'] }
                    }]
                });
            }

            // Create a writable stream
            const writable = await fileHandle.createWritable();

            // Write the content
            await writable.write(passwordHistory);

            // Close the file
            await writable.close();

            // Visual feedback - SUCCESS
            const originalText = downloadBtn.innerHTML;
            downloadBtn.innerHTML = `
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                </svg>
                Saved to File!
            `;

            setTimeout(() => {
                downloadBtn.innerHTML = originalText;
            }, 2000);

        } else {
            // Fallback: Use regular download for browsers that don't support File System Access API
            const blob = new Blob([passwordHistory], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `password-history.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Visual feedback - DOWNLOADED
            const originalText = downloadBtn.innerHTML;
            downloadBtn.innerHTML = `
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                </svg>
                Downloaded!
            `;

            setTimeout(() => {
                downloadBtn.innerHTML = originalText;
            }, 2000);
        }

    } catch (err) {
        // User cancelled file picker or error occurred
        if (err.name !== 'AbortError') {
            console.error('Error saving file:', err);
            alert('Failed to save file. Please try again.');
        }
    }
}

// Event Listeners
generateBtn.addEventListener('click', handleGenerate);
regenerateBtn.addEventListener('click', handleGenerate);
copyBtn.addEventListener('click', copyToClipboard);
downloadBtn.addEventListener('click', downloadPassword);

// Allow Enter key to generate
document.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !passwordDisplay.classList.contains('hidden')) {
        handleGenerate();
    }
});

// Initialize
console.log('AI Password Generator initialized successfully!');
console.log('All processing happens locally - your data never leaves your browser.');
console.log('Passwords save directly to YOUR chosen file location!');
